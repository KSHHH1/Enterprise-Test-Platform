# 企业级自动测试平台 - Web界面开发计划

## 1. 项目摘要

本报告详细记录了针对AITALK产品的拉距测试，旨在验证其在速率4模式下的性能表现，包括传输距离、信号稳定性及抗干扰能力。测试于2025年7月在城市河道的开放环境中进行，利用专业的测试设备和道生物联的标准开发板，确保了测试条件的标准化与结果的准确性。

## 2. 项目愿景

淘汰现有的本地GUI工具 (`pytest_runner_gui.py`)，构建一个现代化的、企业级的Web测试平台。该平台旨在成为测试团队的核心枢纽，实现以下战略目标：

-   **集中化管理**: 将所有测试硬件（工作站）、测试项目、配置和历史数据集中管理，消除信息孤岛。
-   **极致易用性**: 提供一个“仪表盘式”的直观界面，通过向导式操作和实时状态反馈，让测试过程透明、简单、可控。
-   **智能与自动化**: 不仅仅是执行测试，更要具备资源调度、失败诊断、自动报告等智能化能力。
-   **可靠与可追溯**: 保障多用户环境下的操作安全与数据一致性，所有操作均有据可查，精确到具体的操作设备。
-   **远程与协同**: 允许团队成员在任何授权设备上安全地登录并协同工作。

## 3. 核心架构

平台将采用现代化的微服务思想进行解耦设计，确保其可扩展性、可靠性和可维护性。

-   **Web门户 (前端)**: 用户与之交互的唯一入口，负责展示数据和发送用户指令。
-   **编排器 (Orchestrator - 后端核心)**: 平台的大脑，负责处理API请求、用户认证、设备管理、任务分发和状态协调。
-   **数据库 (Database)**: 持久化存储所有关键数据，包括用户信息、设备信息、测试配置、历史记录、测试结果等。
-   **消息队列 (Message Queue)**: 系统的“缓冲带”，用于异步处理测试任务，解耦编排器和测试节点，确保任务在系统繁忙或短暂故障时不会丢失。
-   **测试节点代理 (Node Agent)**: 运行在每一台物理测试工作站上的轻量级程序，负责接收并执行来自消息队列的测试指令，并回报结果。

## 4. 技术选型

-   **后端框架**: **Flask** (或 FastAPI)
    -   原因：与现有Python生态无缝集成，轻量且强大。FastAPI是更现代的选择，天然支持异步，性能更佳。
-   **前端技术**: **HTML, CSS, JavaScript**
    -   原因：初期保持轻量，快速实现核心功能。未来可根据需要引入Vue.js等框架以实现更复杂的UI。
-   **数据库**: **PostgreSQL**
    -   原因：功能强大、稳定可靠的开源关系型数据库，足以支持未来的复杂查询和数据分析。
-   **实时通信**: **WebSocket** (例如通过 Flask-SocketIO)
    -   原因：替代传统的HTTP轮询，实现服务器与客户端之间的真正双向实时通信，为用户提供无延迟的界面状态更新（如节点忙闲状态、日志流等）。
-   **认证机制**: **JWT (JSON Web Token)**
    -   原因：实现无状态认证，天然支持多设备同时登录且互不干扰，是现代Web应用的安全基石。

## 5. 关键特性 (Features)

### 5.1. 统一账户与设备指纹认证

-   **共享账户登录**: 系统内设一个共享账户和密码，简化团队成员的登录过程。
-   **设备首次登录注册**: 当用户在新设备上首次登录时，系统会：
    1.  **自动生成建议名称**: 基于浏览器、操作系统和IP地址等信息，为设备生成一个如“Windows上的Chrome (来自上海市)”的智能建议名称。
    2.  **用户确认或修改**: 弹窗让用户确认该名称或修改为更具辨识度的名称（如“产线-测试工位01”）。
    3.  **设备指纹存储**: 注册成功后，浏览器会永久保存该设备的唯一ID（设备指纹）。
-   **无感快速登录**: 在已注册设备上，用户输入共享密码即可直接登录，无需再次命名。
-   **操作可追溯**: 所有的资源锁定和操作日志都将与**设备名称**绑定，而不是模糊的用户账户。

### 5.2. 实时测试控制台

-   **仪表盘视图**: 登录后的首页，以卡片和状态灯形式清晰展示所有测试节点的实时状态（可用、正忙、离线）。
-   **即时资源锁定 (无排队)**:
    -   用户只能在节点状态为**[可用]**时发起测试。
    -   一旦用户发起测试，该节点状态会立即锁定为**[正忙]**，并实时同步到所有其他用户的界面上。
    -   若两个用户几乎同时操作，由后端的原子锁机制确保只有一个用户成功，另一用户会收到友好的“已被抢占”提示。
-   **向导式测试配置**: 通过分步引导，让用户依次选择项目、测试套件、配置核心参数，极大降低误操作风险。

### 5.2.1 仪表盘自动化测试页面设计建议

为满足企业级自动化测试需求，仪表盘页面建议实现如下功能分层与交互流程：

- **主机发现与管理**：
    - 支持自动或手动扫描公司局域网（如192.168.20.x段），列出在线测试节点（PC），显示主机名、IP、在线状态。
    - 支持手动输入IP添加主机。
    - 技术建议：后端可用ping、ARP、nmap等方式扫描，前端展示主机列表。

- **串口设备管理**：
    - 选中主机后，自动查询其所有可用串口（如COM1、COM2…）。
    - 主机下拉展开，显示串口列表，支持选择。
    - 技术建议：每台PC需部署Agent，负责上报本机串口信息，前端通过API获取。

- **测试用例管理与下发**：
    - 通过选定串口，远程在目标主机D盘新建/同步`TEST_CASES`文件夹，上传/选择测试用例。
    - 串口下方显示用例列表，支持上传、删除、选择用例并下发执行。
    - 技术建议：Agent监听API指令，自动创建文件夹、同步用例文件。

- **测试执行与日志收集**：
    - 远程触发用例执行，实时收集串口日志，支持查看和下载。
    - 用例执行时弹出日志窗口/面板，支持实时刷新、历史查询、导出。
    - 技术建议：Agent将串口输出实时推送到后端，后端通过WebSocket推送到前端。

- **测试报告生成与下载**：
    - 用例执行完毕后，自动生成测试报告（如HTML/PDF/Excel），支持下载和归档。
    - 每次测试有“报告”按钮，点击可查看/下载。
    - 技术建议：后端统一生成报告文件，前端提供下载入口。

#### 页面交互流程（建议）

1. 仪表盘首页自动列出在线主机，支持手动添加IP。
2. 选中主机，自动拉取串口列表。
3. 选中串口，显示/上传/选择用例。
4. 选择用例，点击“执行”，实时显示日志。
5. 执行完毕，自动生成报告，支持下载、历史查询。

#### 技术实现建议

- 后端中心服务（Flask/FastAPI）负责主机发现、任务分发、日志收集、报告生成。
- 每台测试PC需部署Agent（建议Python实现），负责串口管理、用例同步、执行、日志上传。
- 中心服务与Agent通过HTTP API/WebSocket通信。
- 前端仪表盘UI建议采用React/Vue/Ant Design等，支持主机、串口、用例、日志、报告多视图切换。
- WebSocket用于实时日志推送，文件上传/下载用于用例和报告管理。

#### 创新与优化建议

- 主机分组/标签，便于批量管理。
- 用例模板库，常用用例可一键下发到多台主机。
- 权限管理，不同用户可分配不同主机/用例操作权限。
- 自动化调度，支持定时/批量执行用例，自动收集结果。
- 健康监控，主机/串口状态实时监控，异常自动告警。

#### 页面原型草图（文字版）

```
+-------------------------------------------------------------+
| [主机搜索]  [添加IP]  [刷新]                                |
+-------------------+-------------------+---------------------+
| 主机列表          | 串口列表          | 用例与日志           |
| 192.168.20.31     | COM1              | [上传用例] [执行]    |
| 192.168.20.32     | COM2              | 用例1  [报告]        |
| ...               | ...               | 用例2  [报告]        |
+-------------------+-------------------+---------------------+
```

### 5.2.2 仪表盘页面布局与远程测试机搜索方案

为实现“外网用户通过登录即可访问公司内所有测试机并远程下发测试”的目标，建议仪表盘页面采用如下布局与交互设计：

#### 页面整体布局建议

- **顶部导航栏**：
    - 显示平台Logo、系统名称、当前用户信息、登出按钮。
    - 可扩展为多标签页（如“仪表盘”、“历史记录”、“系统设置”等）。

- **主内容区**：
    - **左侧：测试机搜索与分组面板**
        - 提供“搜索框”支持按IP、主机名、标签等模糊搜索。
        - 支持分组（如“上海分部”、“北京分部”），或按在线/离线状态分类。
        - 搜索结果以“卡片”或“列表”形式展示，每台测试机显示：主机名、IP、在线状态、可用串口数、标签等。
        - 支持“刷新”按钮，实时获取最新主机状态。
    - **中间：主机详情与串口/用例操作区**
        - 选中某台主机后，展示其详细信息（IP、操作系统、在线时长、串口列表等）。
        - 串口列表支持展开/收起，显示每个串口的状态（空闲/占用）、速率、备注。
        - 支持上传/选择/下发测试用例，执行用例后实时显示日志。
    - **右侧：日志与报告区**
        - 实时显示当前测试日志，支持历史日志查询、导出。
        - 测试完成后，自动生成报告，支持下载。

#### 测试机搜索与展示方式

- **搜索方式**：
    - 支持自动发现（局域网内通过nmap/ARP/ping等方式，外网通过Agent定期心跳上报）。
    - 支持手动添加IP/主机名。
    - 支持按标签、分组、状态筛选。
- **展示形式**：
    - 推荐“卡片式”展示，直观显示主机状态、串口数、标签等，便于批量操作。
    - 列表模式适合大规模主机管理，可按字段排序。
    - 每台主机卡片/行可点击进入详情。

#### 远程访问与安全策略建议

- **统一登录入口**：所有外网用户通过统一的登录页面认证（如JWT），登录后可访问仪表盘。
- **权限与隔离**：
    - 支持为不同用户分配可访问的主机/串口范围，防止误操作。
    - 重要操作（如下发用例、重启主机）需二次确认。
- **安全通信**：
    - 前后端、中心服务与Agent间均采用HTTPS/WSS加密通信。
    - Agent仅接受来自中心服务的指令，避免被外部恶意利用。
- **主机状态实时同步**：
    - Agent定期向中心服务上报状态（在线/离线、串口占用、当前任务等），仪表盘实时刷新。

#### 页面原型草图（文字版）

```
+---------------------------------------------------------------+
| Logo | 仪表盘 | 历史记录 | 设置 | 用户名 | 退出                |
+-------------------+---------------------+---------------------+
| [搜索] [分组]     | 主机详情           | 日志/报告           |
| [刷新]           | 串口列表           | 实时日志            |
| [主机卡片/列表]  | 用例上传/下发/执行 | 报告下载            |
+-------------------+---------------------+---------------------+
```

#### 交互流程示例

1. 用户登录后进入仪表盘，左侧自动/手动搜索并展示所有可用测试机。
2. 选中主机，查看其串口与状态，上传/选择测试用例。
3. 下发用例并执行，实时查看日志，测试完成后下载报告。
4. 支持多用户并发访问，权限可控，操作安全。

### 5.3. 智能监控与结果展示

-   **实时日志流**: 通过WebSocket，将测试脚本产生的日志实时推送到Web前端的日志窗口。
-   **分层结果视图**:
    1.  **摘要层**: 测试结束后，在页面顶部明确展示“测试通过/失败”的最终结论，并附上耗时、关键结果等核心摘要。
    2.  **分析层**: 以图表和表格形式，清晰展示格式化后的结果数据，如安全频点列表、已排除频点及其原因等。
    3.  **原始数据层**: 提供可搜索、可下载的原始日志文件和产物文件 (`.json`)。

### 5.4. 自动化报告

-   测试完成后，系统可根据预设模板，自动生成精美的、可供分发的HTML或PDF格式测试报告。

## 6. 安全与可靠性

-   **并发控制**: 通过数据库和编排器的状态锁定机制，从根本上杜绝多用户同时操作同一硬件资源引发的冲突。
-   **API安全**: 所有API端点均通过JWT进行保护。
-   **容错能力**: 消息队列确保了即使编排器或节点短暂重启，测试任务也不会丢失。

## 7. 部署策略

-   **推荐方案**: 使用 **Docker & Docker Compose** 进行容器化部署。这可以将后端应用、数据库、消息队列等所有服务打包，实现一键启动，极大简化在任何机器上的部署和环境配置过程。
-   **网络访问**: 初期在局域网内通过IP地址访问。未来若需公网访问，必须通过Nginx等反向代理，并配置HTTPS来保障通信安全。

## 8. 项目文件结构 (建议)

```
8710AUTOTEST/
├── test_platform/
│   ├── app.py              # 应用入口：创建App、初始化扩展、注册蓝图
│   ├── core/               # 核心模块 (登录页等)
│   │   ├── __init__.py
│   │   └── routes.py
│   ├── auth/               # 认证模块
│   │   ├── __init__.py
│   │   ├── routes.py       # API路由
│   │   └── services.py     # 业务逻辑
│   ├── dashboard/          # 仪表盘模块
│   │   ├── __init__.py
│   │   ├── routes.py       # 页面路由
│   │   └── sockets.py      # WebSocket事件
│   ├── models/             # 数据库模型
│   │   ├── __init__.py
│   │   └── device.py
│   ├── tasks.py            # 异步任务 (待重构)
│   ├── templates/          # 全局HTML模板
│   │   ├── index.html
│   │   └── login.html
│   └── static/             # 全局静态文件
│       ├── css/style.css
│       └── js/main.js
├── docker-compose.yml      # 用于一键部署所有服务
├── Dockerfile              # 后端应用的容器化配置
├── test_cases/
│   └── ...                 # 测试脚本保持独立
└── ...
```

## 9. 项目排期与时间预估 (V1.0)

本文档预估了在配备一名经验丰富的全栈开发人员的情况下，完成平台V1.0版本所需的总时间。估算已包含开发、集成、独立测试及BUG修复所需的全部时间。

**总预估时间: 10 - 15 周**

---

### **P1: 后端核心 (阶段总计: 2 - 3 周)**
*   **核心任务**:
    *   `[已完成]` 搭建Docker环境与服务编排 (DB, MQ)
    *   `[已完成]` 设计并创建数据库模型
    *   `[已完成]` 开发JWT认证与设备指纹识别API
    *   `[未开始]` 开发基础资源管理API
*   **关键产出**:
    *   可通过API管理的后端服务
    *   稳定的数据库结构
    *   可靠的认证系统
    *   `docker-compose.yml`

---

### **P2: 前端与交互 (阶段总计: 2.5 - 3.5 周)**
*   **核心任务**:
    *   `[已完成]` 实现登录与设备注册UI
    *   `[部分完成]` 开发仪表盘实时视图 (已创建页面框架)
    *   `[部分完成]` 集成WebSocket实现实时状态同步 (已建立连接)
    *   `[未开始]` 实现前端资源锁定与防冲突逻辑
*   **关键产出**:
    *   用户可登录的Web界面
    *   实时更新的设备状态仪表盘
    *   响应式的UI交互逻辑

---

### **P3: 测试执行 (阶段总计: 2 - 3 周)**
*   **核心任务**:
    *   开发任务分发与队列管理逻辑
    *   **开发健壮的测试节点代理(Node Agent)**
    *   联调从Web到物理节点的完整测试链路
    *   实现实时日志流
*   **关键产出**:
    *   可靠的任务消息队列机制
    *   可独立运行的节点代理程序
    *   **可从Web端完整触发并监控的测试流程**

---

### **P4: 高级功能 (阶段总计: 1 - 1.5 周)**
*   **核心任务**:
    *   开发分层结果展示
    *   开发历史记录查询功能
    *   实现自动化报告生成与下载
*   **关键产出**:
    *   清晰、可交互的结果分析界面
    *   可追溯的测试历史数据库
    *   可导出的HTML/Markdown报告

---

### **P5: 系统测试 (阶段总计: 1.5 - 2 周)**
*   **核心任务**:
    *   **编写全面的系统测试用例**
    *   执行功能、集成和端到端测试
    *   进行探索性测试，寻找边缘BUG
    *   **提交详细的缺陷报告**
*   **关键产出**:
    *   完整的测试用例集
    *   全面的系统测试报告
    *   清晰的待修复BUG列表

---

### **P6: 修复与上线 (阶段总计: 1 - 2 周)**
*   **核心任务**:
    *   **集中修复P5中发现的所有关键BUG**
    *   进行必要的回归测试
    *   最终生产环境部署
    *   定稿技术与用户文档
*   **关键产出**:
    *   **一个稳定、可靠、经过验证的V1.0平台**
    *   最终版的部署与用户手册

# 10. 附录：项目开发日志

本文档记录了项目从本地脚本优化到企业级平台构想的完整演进历程。

## 第一阶段：本地测试脚本的深度优化与重构

项目启动于对现有 `pytest_runner_gui.py` 和 `test_yipin_iterative_search.py` 的一系列改进。

-   **核心问题修复**:
    1.  **参数冲突**: 解决了GUI配置与测试线程中硬编码参数 (`WORK_MODE=21, RATE=11`) 的冲突问题，确保了配置的唯一来源。
    2.  **端口识别失败**: 重构了测试脚本的参数解析逻辑，从无效的`fixture`改为标准的`request.config.getoption()`，解决了因无法正确获取端口而导致的测试失败。
    3.  **线程死锁**: 修复了因在`threading.Lock`锁内重复获取锁导致的程序卡死问题，通过替换为`threading.RLock`（可重入锁）解决了死锁。

-   **功能与逻辑的迭代升级**:
    1.  **结果日志进化 (三代)**:
        *   **V1**: 将结果从简单的频点列表，升级为可分类记录排除原因（如“32MHz倍频”、“与xx频点冲突”）的结构化JSON。
        *   **V2**: 引入“任务板”概念，增加了`pending_frequencies`（待测列表），使测试进度可被追踪，并能从中断处恢复。
        *   **V3**: 融合前两代优点，在“任务板”的基础上，为“已排除频点”列表恢复了详细的冲突对象信息，实现了进度跟踪与详细诊断的统一。
    2.  **测试逻辑完备性**:
        *   **同频自检**: 增加了`verify_self_communication`函数，在进行隔离性测试前，先验证频点自身基础通信的可用性，堵住了“将一个完全不通的频点误判为安全”的逻辑漏洞。
        *   **精细化搜索**: 恢复并完善了`find_alternative_freq`函数，当候选频点（200kHz步长）冲突时，能在其附近以3kHz的步长寻找替代品，而非直接放弃。
    3.  **模拟验证**: 为了在脱离硬件的环境下验证上述复杂逻辑，为脚本引入了`SIMULATION_MODE`，通过预设数据和断言，成功验证了所有逻辑分支的正确性。

-   **GUI体验优化**:
    *   响应用户最初需求，将“开始测试”按钮在测试过程中切换为“暂停/继续”的逻辑框架搭建完成（尽管后续因暂停功能在业务上非必须而未深入）。

## 第二阶段：从工具到平台——企业级Web界面的规划

在本地脚本的健壮性和功能性得到根本性提升后，为了解决可维护性、可扩展性和多人协作的挑战，项目进入了平台化规划阶段。

-   **规划的演进**:
    *   **V1.0 (基础版)**: 构思一个简单的Web界面作为GUI替代品。
    *   **V2.0 (Dashboard-Bot)**: 引入数据持久化和可视化，将平台升级为带数据分析能力的“自动化测试平台”。
    *   **V3.0 (通用平台)**: 将平台重构为支持多项目、多测试套件的通用框架。
    *   **V4.0 (分布式专用节点)**: 引入“节点能力标签”，使平台能调度运行在不同硬件配置的专用工作站上的测试。
    *   **V5.0 (终极蓝图 - 混合测试云)**: 引入“资源池”和智能调度，实现对同构节点的负载均衡和故障转移，构建“自愈的、AI驱动的”测试云终极蓝图。

-   **核心特性确定**:
    *   **认证**: 确定了“共享账户+设备指纹”的认证模式，兼顾便捷与可追溯性。
    *   **并发控制**: 确定了“即时锁定，无缝刷新”的方案，杜绝资源冲突。
    *   **用户体验**: 确定了“仪表盘优先”、“向导式操作”、“分层结果展示”的设计原则。

-   **当前进度**:
    *   **完成**: 已根据最终蓝图，完成了Web平台的V1版本地框架搭建，包括使用Flask的后端、前端模板、`Dockerfile`和`docker-compose.yml`。整个应用已成功容器化运行，并实现了完整的、包含设备指纹识别的用户登录与注册流程。用户现在可以通过浏览器访问登录页面。

## 第三阶段：容器化部署的调试与健壮性加固

在完成V1版本地框架搭建后，项目进入了密集的部署调试阶段。此阶段的核心目标是解决在Docker环境下因状态不一致而导致的反复启动失败问题，并最终形成一个健壮、可靠的启动流程。

-   **核心挑战定位**:
    1.  **状态不一致**: 明确了问题的根源在于Docker的数据卷（Volume）持久化机制。当代码（特别是数据库迁移脚本）发生变化时，旧的数据库数据卷并未被自动清理，导致Web容器启动时发现历史记录与代码文件不匹配（`Can't locate revision` 错误），从而崩溃。
    2.  **启动脚本脆弱性**: 最初的启动命令序列不够健壮，无法应对数据库已经存在或部分初始化的情况。

-   **关键修复与迭代**:
    1.  **引入`entrypoint.sh`启动脚本**: 将数据库初始化和迁移的逻辑从`docker-compose.yml`的`command`中移出，封装到一个独立的`entrypoint.sh`脚本中。此脚本通过检查`migrations`目录是否存在，来智能判断应该执行初始化还是仅执行升级。
    2.  **修复Flask扩展初始化**: 解决了因`Flask-Migrate`扩展未在应用工厂 (`create_app`) 中正确初始化而导致的`flask db`命令不存在的问题。
    3.  **前端逻辑优化**: 修复了因在登录页面提前初始化WebSocket而导致的JavaScript执行中断、登录按钮失效的BUG。
    4.  **配置外部化**: 将硬编码在代码中的共享访问密码 (`SHARED_PASSWORD`) 移至`docker-compose.yml`中，通过环境变量进行管理，提升了安全性与灵活性。
    5.  **最终加固方案**:
        *   **规范化操作流程**: 确立了`docker-compose down -v`（彻底清理，包括数据卷） -> `docker-compose up --build`（重新构建并启动）的黄金操作流程。
        *   **强化启动脚本**: 为`entrypoint.sh`增加了`rm -rf migrations`指令，强制要求每次容器启动都重新生成迁移状态，从根本上杜绝了因数据卷缓存导致的“状态不一致”问题，使系统具备了“自愈”能力。

-   **阶段成果**:
    *   成功解决了所有已知的容器启动失败问题。
    *   获得了一个高度健壮和自动化的部署启动流程，极大提升了开发和维护效率。
    *   项目现在能够稳定地在任何支持Docker的环境中一键启动，并正确显示登录页面。

## 第四阶段：企业级架构重构与模块化

在解决了基本的部署问题后，为防止项目在快速迭代中演变为难以维护的“代码屎山”，我们进行了一次全面的架构重构。

-   **核心挑战**: 随着项目复杂度提升，原有的单文件脚本和混合了多重职责的 `app.py` 已无法满足长期维护和扩展的需求。

-   **关键重构实践**:
    1.  **引入模块化蓝图 (Modular Blueprints)**:
        *   将原先集中在 `app.py` 的路由，按照功能拆分到独立的模块中。
        *   创建了 `core`（核心页面）、`auth`（认证API）、`dashboard`（仪表盘）三个核心蓝图。
        *   使主应用文件 `app.py` 的角色简化为“应用组装器”，只负责初始化和注册蓝图，自身不再包含任何业务路由。
    2.  **建立服务层 (Service Layer)**:
        *   在 `auth` 模块中率先引入了 `services.py` 的概念。
        *   将用户认证、设备注册、JWT生成等核心业务逻辑从视图函数（路由）中剥离，封装到服务函数里。
        *   实现了业务逻辑与HTTP请求处理的彻底分离，提高了代码的可复用性和可测试性。
    3.  **实施功能驱动的目录结构 (Feature-Driven Directory Structure)**:
        *   项目目录结构从按 `models.py`, `routes.py` 等文件类型组织，重构为按 `auth/`, `dashboard/` 等功能模块组织。
        *   每个功能模块包含自己的路由、服务、模板和socket事件，实现了高度的内聚和低耦合。
    4.  **逻辑迁移与清理**:
        *   WebSocket相关逻辑 (`ws.py`) 被迁移到 `dashboard` 模块的 `sockets.py` 中。
        *   数据库模型 (`models.py`) 被迁移到独立的 `models/` 包中，为未来更复杂的模型管理提供基础。

-   **阶段成果**:
    *   项目拥有了一个清晰、可扩展、符合现代Web开发实践的企业级架构。
    *   为未来添加新功能（如测试任务管理、结果报告）打下了坚实的基础，能有效避免代码腐化。
    *   项目整体的可维护性、可读性得到大幅提升。

### 5.2.3 简化版仪表盘与测试页面交互流程（合并一页式设计）

为提升操作效率，建议将测试页面与仪表盘首页合并为一页式布局：用户在主机列表中选中电脑后，右侧直接展开该主机的测试区，无需跳转页面。

#### 1. 仪表盘首页（主机列表+测试区并列）
- 左侧为“可用电脑”列表，每台电脑显示：
    - 电脑名称（可自定义，如“测试机A”）
    - IP地址（如192.168.20.31）
    - 物理位置（如“上海实验室-工位3”）
    - 当前状态（空闲/忙碌）
    - [进入] 按钮或直接点击行选中
- 支持“添加电脑”功能，用户可手动输入IP地址、名称、位置。
- 状态实时刷新，空闲/忙碌一目了然。

- 右侧为“测试区”，显示当前选中电脑的：
    - 详细信息（名称、IP、位置、状态）
    - 串口列表（如COM1、COM2…）
    - 测试用例列表（`TEST_CASES`文件夹下所有用例）
    - 支持单用例测试、全部测试、实时日志、报告下载

#### 2. 页面原型草图（文字版）

```
+-------------------+-----------------------------------------------+
| 主机列表          | 主机详情/测试区                               |
|-------------------|-----------------------------------------------|
| [添加][刷新]      | 电脑：测试机A  IP:192.168.20.31  位置:上海-3 |
|                   | 串口：COM1  COM2 ...                          |
| 测试机A  空闲     | 测试用例：                                    |
| 测试机B  忙碌     | [ ] 用例1   [测试]                            |
| ...               | [ ] 用例2   [测试]                            |
|                   | ...                                           |
|                   | [全部测试]                                    |
|                   | 日志输出区...                                 |
|                   | [下载报告]                                    |
+-------------------+-----------------------------------------------+
```

#### 3. 设计要点
- 所有操作均在同一页面完成，提升用户体验。
- 选中主机后，右侧测试区内容实时切换。
- 支持后期维护电脑信息（增删改IP、名称、位置）。
- 用例和串口信息由后端/Agent实时获取。
- 支持单用例和批量测试，日志与报告功能保留。

# 附录：项目开发日志 (最新更新)

本文档记录了项目从本地脚本优化到企业级平台构想，再到Web界面初步实现的完整演进历程。

## 第三阶段：Web界面的初步实现与后端对接

在完成了平台化的顶层设计后，我们进入了Web界面的实际开发阶段，并遇到了新的挑战。

*   **前端界面优化 (`index.html`):**
    *   **串口显示逻辑修改:** 根据用户反馈，将原先需要手动选择串口的单选按钮，改为了直接展示可用串口的纯文本，并默认选中第一个。此举简化了操作，并初步解决了界面加载缓慢的问题。
    *   **日志显示功能增强:** 对前端日志区域进行了大幅优化，包括实现 `SUCCESS`, `ERROR`, `INFO` 等关键词的颜色高亮、保留日志换行、自动滚动到底部以及增加显示区域高度，显著提升了日志的可读性和用户体验。

*   **后端脚本执行逻辑分析:**
    *   **问题根源定位:** 通过对代码的追踪，我们确认了前端的“执行”操作最终调用的是 `agent/agent.py` 中的 `run_case` 接口。
    *   **发现模拟执行 (Mock):** 深入分析 `agent.py` 后发现，当前的 `run_case` 函数 **并未真正执行物理测试脚本**，而是返回一个固定的、模拟的成功日志。这是导致用户感觉“脚本未被执行”的根本原因。

*   **核心待办事项:**
    *   **实现真实脚本调用:** 下一阶段的核心任务是重构 `agent/agent.py` 中的 `run_case` 函数，利用Python的 `subprocess` 模块来调用 `test_cases/` 目录下的真实测试脚本。
    *   **捕获并返回实时输出:** 在调用脚本时，需要捕获其标准输出和错误流，并将其通过API实时返回给前端，以在日志区域中真实地展示脚本执行过程。
